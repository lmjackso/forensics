forensics
=========

To Run: 
1) Make sure you have pip installed on your system. Otherwise use your favorite package manager to install it into your system.
2) Create a new virtual environment and activate it.
3) Navigate to the head of the project handin directory and run 
	pip install -r requirements.txt
4) Navigate to term_project and run
	python manage.py runserver
5) Open a browser and open http://localhost:8000/

NOTE: When creating JS files within the /DFA/static/options, don't have any JS files with the same name!

Adding a new graphical representation:

1) Pick a name for the visualization you would like to add
2) Create two files: <name>.js and <name>_type.js
3) In <name>_type.js, add the following line to add the types of metadata you would like your visualization to display:
	var types = [<type 1>, <type 2>...]
4) In <name>.js, include all of the d3 visualization code. Make sure the chart is appended to the ".chart" class.
5) Place javascript of graphical representation into /DFA/static/options
6) Place <filename>_type.js into DFA/static/options/types
7) Within the main DFA directory, if you want to use manipulate meta data before passing onto your graph, simply create a new clause with the following line:

elif(metatype == '<metadata>'):
			key = metatype
			for fileName in list_dir:
				if fileName is not None:

					testfile = fileName.split("/")
					fileName = testfile[-1]
					print "this is the filename = " + fileName
					if fileName != ".DS_Store":
						info = get_value(map_dir[fileName]['metadata'])
						<Place info manipulation code here>
						.
						.
						.
						<Place info manipulation code above>
	

/**export**/

export_metadata(metadata, newname)
	This function takes in two objects, metadata, which is a metadata map, like the object returned from parse_map_from_directory and newname, which is the new path+name of the excel file to be written.

/**parser**/

get_file_size(filename)
	This function returns the numeric size of the file specified by filename, which should include the absolute path of the file.

metadata_map(filename)
	This function extracts the metadata map of Data elements used by hachoir with an input of filename, which corresponds to an absolute path of a file.

get_value(metadata_value):
	This function takes a metadata data object and returns its value.

get_text(metadata_value):
	This function takes a metadata data object and returns the text description of it.

create_list(metadata_map):
	This function takes a metadata map like the one generated by metadata_map(filename) and generates a list of elements formatted like this [<key>, <value>].

list_to_parse(rootdir):
	This function takes the absolute path of the directory at the root of the files you want to parse.  This then returns an array of full file names to be processed.

get_extension(filename):
	This function returns the file extension contained within the filename.

name_extension_tuple(filename):
	This function takes in a file name and outputs a two element list, one being the filename including the extension and the second being the extension.

tuple_list(list):
	This function applies name_extension_tuple to a list of file names, rather than just one.

metadata_for_filelike(filelike):
	This function attempts to retrieve a metadata map from a file whose type is not known.  It's input is a file name or I/O stream and it's output is a metadata map.

parse_map_from_directory(directory):
	This function takes a directory, and parses every file inside of it for metadata.  It then constructs a map of filenames to their corresponding metadata maps.  This map of filenames to the corresponding typed metadata maps is what this function returns.  The map of metadata maps between description of the field and the value of the field, which is originally in a Data object.  In order to retrieve the value in as a native python object, use the function get_value, provided.  

	i.e.
	directory = "User/lmjackso/Private/Test"
	filename = "User/lmjackso/Private/Test/test.png"

	get_value(parse_map_from_directory(directory)[filename]['width'])
	>> some number of pixels, i.e. 1920

/**helper**/
filter_map_by_extension(extension,metadatamap)
	This function takes in a map like the one parsed from parse_map_from_directory(directory) and a file extension, and returns a filtered map that only contains files of the type specified by the file extension input.
	
***********CURRET LIST OF VALID METADATA FIELDS**********

**COMMON/POPULAR CHOICES**
latitude
mime_type 
longitude 
duration
last_modification
creation_date
**************************
comment
frame_rate
file_type
pixel_format
file_size
camera_brightness
height
bit_rate
bits_per_pixel
album
city
nb_page
copyright
author
image_orientation
altitude
charset
filename
width
version
location
sample_rate
height_dpi
format_version
camera_aperture
camera_manufacturer
width_dpi
font_weight
music_genre
subtitle_author 
nb_colors 
os 
bits_per_sample
camera_focal 
camera_exposure
creation_date 
compression 
nb_channel 
language 
artist 
url 
country
title 
track_total
track_number
compr_size 
camera_model
music_composer
file_attr 
endian 
aspect_ratio
organization
compr_rate 